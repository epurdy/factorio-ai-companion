# v0.2.2 Companions and Actions Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add companion character spawning with subcommands and port FLE action commands for Factorio 2.x

**Architecture:** Subcommand parser in `/fac` routes to spawn/list/kill/clear/thread handlers. Companions stored in `storage.companions = {}` with auto-incrementing numeric IDs. Actions use "fast mode" (instant teleport/craft) for responsive control via RCON.

**Tech Stack:** Lua (Factorio mod API 2.x), TypeScript (RCON client)

---

## FLE → 2.x Compatibility Notes

| FLE 1.x Pattern | Factorio 2.x Equivalent |
|-----------------|-------------------------|
| `global` | `storage` |
| `global.agent_characters[i]` | `storage.companions[id]` |
| `game.table_to_json()` | `helpers.table_to_json()` |
| `game.item_prototypes[name]` | `prototypes.item[name]` |
| `game.entity_prototypes[name]` | `prototypes.entity[name]` |
| `game.recipe_prototypes[name]` | `prototypes.recipe[name]` |

---

### Task 1: Add Subcommand Parser to /fac

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua:59-67`

**Step 1: Replace handle_companion_command with subcommand parser**

Replace the `/fac` command handler with:

```lua
-- Subcommand parser for /fac
local function parse_subcommand(parameter)
  if not parameter or parameter == "" then
    return nil, nil
  end
  local cmd, rest = parameter:match("^(%S+)%s*(.*)")
  return cmd, rest
end

local function handle_fac_command(command)
  local success, error_msg = pcall(function()
    local player
    if command.player_index then
      player = game.players[command.player_index]
      if not player or not player.valid then return end
    end

    local subcommand, args = parse_subcommand(command.parameter)

    if not subcommand then
      if player then
        player.print("[AI Companion] Usage: /fac <message> | /fac spawn [n] | /fac list | /fac kill [id] | /fac clear | /fac thread [id] <message>", {r=1, g=0.5, b=0})
      end
      return
    end

    -- Route subcommands
    if subcommand == "spawn" then
      handle_spawn(player, args)
    elseif subcommand == "list" then
      handle_list(player)
    elseif subcommand == "kill" then
      handle_kill(player, args)
    elseif subcommand == "clear" then
      handle_clear(player)
    elseif subcommand == "thread" then
      handle_thread(player, args)
    else
      -- Default: treat as chat message
      handle_chat(player, command.parameter)
    end
  end)

  if not success then
    game.print("[AI Companion] Error: " .. tostring(error_msg), {r=1, g=0, b=0})
  end
end
```

**Step 2: Run Factorio and test subcommand parsing**

Load game, type `/fac test` - should route to chat.
Type `/fac spawn` - should show "not implemented" (temporary).

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add subcommand parser for /fac"
```

---

### Task 2: Implement Companion Storage and spawn/list/kill

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion storage initialization**

Update `on_init` and `on_configuration_changed`:

```lua
script.on_init(function()
  storage.companion_messages = {}
  storage.companion_tick_counter = 0
  storage.companions = {}           -- {id = {entity=entity, name="Companion 1"}}
  storage.companion_next_id = 1     -- Auto-incrementing ID
  game.print("[AI Companion] Mod initialized! Type /fac <message> to chat with Claude", {r=0.5, g=0.8, b=1})
end)

script.on_configuration_changed(function()
  storage.companion_messages = storage.companion_messages or {}
  storage.companion_tick_counter = storage.companion_tick_counter or 0
  storage.companions = storage.companions or {}
  storage.companion_next_id = storage.companion_next_id or 1
  game.print("[AI Companion] Mod updated!", {r=0.5, g=0.8, b=1})
end)
```

**Step 2: Implement spawn handler**

```lua
local function handle_spawn(player, args)
  local count = tonumber(args) or 1
  count = math.min(count, 10) -- Limit to 10 at a time

  local spawned = {}
  for i = 1, count do
    local id = storage.companion_next_id
    storage.companion_next_id = storage.companion_next_id + 1

    -- Spawn position near player
    local pos = player.position
    local spawn_pos = {x = pos.x + (i * 2), y = pos.y}

    -- Create character entity
    local entity = player.surface.create_entity{
      name = "character",
      position = spawn_pos,
      force = player.force
    }

    if entity then
      storage.companions[id] = {
        entity = entity,
        name = "Companion " .. id,
        spawned_by = player.name,
        spawned_tick = game.tick
      }
      table.insert(spawned, id)
    end
  end

  if #spawned > 0 then
    game.print("[AI Companion] Spawned companion(s): " .. table.concat(spawned, ", "), {r=0.3, g=1, b=0.3})
  else
    game.print("[AI Companion] Failed to spawn companions", {r=1, g=0, b=0})
  end
end
```

**Step 3: Implement list handler**

```lua
local function handle_list(player)
  local count = 0
  local list = {}

  for id, companion in pairs(storage.companions) do
    if companion.entity and companion.entity.valid then
      local pos = companion.entity.position
      table.insert(list, string.format("#%d at (%.1f, %.1f)", id, pos.x, pos.y))
      count = count + 1
    else
      -- Clean up invalid companions
      storage.companions[id] = nil
    end
  end

  if count > 0 then
    game.print("[AI Companion] Active companions: " .. table.concat(list, ", "), {r=0.5, g=0.8, b=1})
  else
    game.print("[AI Companion] No active companions. Use /fac spawn to create one.", {r=0.5, g=0.8, b=1})
  end
end
```

**Step 4: Implement kill handler**

```lua
local function handle_kill(player, args)
  local id = tonumber(args)

  if not id then
    -- Kill all
    local killed = 0
    for cid, companion in pairs(storage.companions) do
      if companion.entity and companion.entity.valid then
        companion.entity.destroy()
        killed = killed + 1
      end
      storage.companions[cid] = nil
    end
    game.print("[AI Companion] Killed " .. killed .. " companion(s)", {r=1, g=0.5, b=0})
    return
  end

  local companion = storage.companions[id]
  if companion and companion.entity and companion.entity.valid then
    companion.entity.destroy()
    storage.companions[id] = nil
    game.print("[AI Companion] Killed companion #" .. id, {r=1, g=0.5, b=0})
  else
    game.print("[AI Companion] Companion #" .. id .. " not found", {r=1, g=0, b=0})
  end
end
```

**Step 5: Test in Factorio**

- `/fac spawn` - creates 1 companion
- `/fac spawn 3` - creates 3 companions
- `/fac list` - shows all companions with positions
- `/fac kill 1` - kills companion #1
- `/fac kill` - kills all

**Step 6: Commit**

```bash
git add -A && git commit -m "feat: implement companion spawn/list/kill commands"
```

---

### Task 3: Implement clear and thread Commands

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Implement clear handler**

```lua
local function handle_clear(player)
  -- Clear unread messages
  local cleared = #storage.companion_messages
  storage.companion_messages = {}
  game.print("[AI Companion] Cleared " .. cleared .. " message(s) from queue", {r=0.5, g=0.8, b=1})
end
```

**Step 2: Implement thread handler**

```lua
local function handle_thread(player, args)
  local id_str, message = args:match("^(%d+)%s+(.*)")
  local id = tonumber(id_str)

  if not id or not message or message == "" then
    player.print("[AI Companion] Usage: /fac thread <id> <message>", {r=1, g=0.5, b=0})
    return
  end

  local companion = storage.companions[id]
  if not companion or not companion.entity or not companion.entity.valid then
    player.print("[AI Companion] Companion #" .. id .. " not found", {r=1, g=0, b=0})
    return
  end

  -- Store message with target companion ID
  table.insert(storage.companion_messages, {
    player = player and player.name or "server",
    message = message,
    tick = game.tick,
    read = false,
    target_companion = id  -- NEW: target specific companion
  })

  local player_name = player and player.name or "server"
  game.print("[" .. player_name .. " → #" .. id .. "] " .. message, {r=0.4, g=0.8, b=1})
end
```

**Step 3: Update chat handler to use original logic**

```lua
local function handle_chat(player, message)
  -- Store the message (original logic)
  table.insert(storage.companion_messages, {
    player = player and player.name or "server",
    message = message,
    tick = game.tick,
    read = false
  })

  -- Acknowledge in chat - player messages in cyan/blue
  local player_name = player and player.name or "server"
  game.print("[" .. player_name .. "] " .. message, {r=0.4, g=0.8, b=1})
end
```

**Step 4: Test in Factorio**

- `/fac clear` - clears message queue
- `/fac hello there` - sends chat message (default)
- `/fac thread 1 move north` - sends to companion #1 only

**Step 5: Commit**

```bash
git add -A && git commit -m "feat: add /fac clear and /fac thread commands"
```

---

### Task 4: Add RCON Commands for Companion Control

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion_list RCON command**

```lua
commands.add_command("companion_list", "List all companions (RCON)", function(command)
  local success, result = pcall(function()
    local companions = {}

    for id, companion in pairs(storage.companions) do
      if companion.entity and companion.entity.valid then
        local pos = companion.entity.position
        table.insert(companions, {
          id = id,
          name = companion.name,
          x = pos.x,
          y = pos.y,
          spawned_by = companion.spawned_by
        })
      end
    end

    local json_success, json_result = pcall(helpers.table_to_json, companions)
    if json_success then
      rcon.print(json_result)
    else
      rcon.print('{"error": "JSON serialization failed"}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 2: Add companion_spawn RCON command**

```lua
commands.add_command("companion_spawn", "Spawn companion via RCON: /companion_spawn [count] [x] [y]", function(command)
  local success, result = pcall(function()
    local args = command.parameter or ""
    local count_str, x_str, y_str = args:match("^(%d*)%s*([%d.-]*)%s*([%d.-]*)$")

    local count = tonumber(count_str) or 1
    count = math.min(count, 10)

    -- Default to first player's position if no coords given
    local player = game.players[1]
    local x = tonumber(x_str) or (player and player.position.x or 0)
    local y = tonumber(y_str) or (player and player.position.y or 0)
    local surface = player and player.surface or game.surfaces[1]
    local force = player and player.force or game.forces["player"]

    local spawned = {}
    for i = 1, count do
      local id = storage.companion_next_id
      storage.companion_next_id = storage.companion_next_id + 1

      local spawn_pos = {x = x + (i * 2), y = y}
      local entity = surface.create_entity{
        name = "character",
        position = spawn_pos,
        force = force
      }

      if entity then
        storage.companions[id] = {
          entity = entity,
          name = "Companion " .. id,
          spawned_by = "rcon",
          spawned_tick = game.tick
        }
        table.insert(spawned, id)
      end
    end

    local json_success, json_result = pcall(helpers.table_to_json, {spawned = spawned})
    if json_success then
      rcon.print(json_result)
    else
      rcon.print('{"error": "JSON serialization failed"}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 3: Add companion_kill RCON command**

```lua
commands.add_command("companion_kill", "Kill companion via RCON: /companion_kill [id]", function(command)
  local success, result = pcall(function()
    local id = tonumber(command.parameter)
    local killed = {}

    if id then
      local companion = storage.companions[id]
      if companion and companion.entity and companion.entity.valid then
        companion.entity.destroy()
        storage.companions[id] = nil
        table.insert(killed, id)
      end
    else
      -- Kill all
      for cid, companion in pairs(storage.companions) do
        if companion.entity and companion.entity.valid then
          companion.entity.destroy()
          table.insert(killed, cid)
        end
        storage.companions[cid] = nil
      end
    end

    local json_success, json_result = pcall(helpers.table_to_json, {killed = killed})
    if json_success then
      rcon.print(json_result)
    else
      rcon.print('{"error": "JSON serialization failed"}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 4: Test via RCON**

```bash
bun -e "
import { RCONClient } from './src/rcon/client';
const client = new RCONClient({ host: '127.0.0.1', port: 34198, password: 'factorio' });
await client.connect();
console.log(await client.sendCommand('/companion_spawn 2'));
console.log(await client.sendCommand('/companion_list'));
console.log(await client.sendCommand('/companion_kill'));
await client.disconnect();
"
```

**Step 5: Commit**

```bash
git add -A && git commit -m "feat: add RCON commands for companion management"
```

---

### Task 5: Implement companion_move RCON Command (Fast Mode)

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion_move command**

Simplified version using instant teleport (FLE "fast mode"):

```lua
commands.add_command("companion_move", "Move companion: /companion_move <id> <x> <y>", function(command)
  local success, result = pcall(function()
    local args = command.parameter or ""
    local id_str, x_str, y_str = args:match("^(%d+)%s+([%d.-]+)%s+([%d.-]+)$")

    local id = tonumber(id_str)
    local x = tonumber(x_str)
    local y = tonumber(y_str)

    if not id or not x or not y then
      rcon.print('{"error": "Usage: /companion_move <id> <x> <y>"}')
      return
    end

    local companion = storage.companions[id]
    if not companion or not companion.entity or not companion.entity.valid then
      rcon.print('{"error": "Companion #' .. id .. ' not found"}')
      return
    end

    local entity = companion.entity
    local old_pos = entity.position

    -- Fast mode: instant teleport
    local teleported = entity.teleport({x = x, y = y})

    if teleported then
      local new_pos = entity.position
      local json_success, json_result = pcall(helpers.table_to_json, {
        id = id,
        from = {x = old_pos.x, y = old_pos.y},
        to = {x = new_pos.x, y = new_pos.y}
      })
      if json_success then
        rcon.print(json_result)
      else
        rcon.print('{"success": true}')
      end
    else
      rcon.print('{"error": "Could not teleport to position"}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 2: Test via RCON**

```bash
bun -e "
import { RCONClient } from './src/rcon/client';
const client = new RCONClient({ host: '127.0.0.1', port: 34198, password: 'factorio' });
await client.connect();
console.log(await client.sendCommand('/companion_spawn'));
console.log(await client.sendCommand('/companion_move 1 10 10'));
await client.disconnect();
"
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add companion_move RCON command (fast mode teleport)"
```

---

### Task 6: Implement companion_mine RCON Command

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion_mine command**

Simplified resource harvesting (fast mode):

```lua
commands.add_command("companion_mine", "Mine resources: /companion_mine <id> <x> <y> [count]", function(command)
  local success, result = pcall(function()
    local args = command.parameter or ""
    local id_str, x_str, y_str, count_str = args:match("^(%d+)%s+([%d.-]+)%s+([%d.-]+)%s*(%d*)$")

    local id = tonumber(id_str)
    local x = tonumber(x_str)
    local y = tonumber(y_str)
    local count = tonumber(count_str) or 5

    if not id or not x or not y then
      rcon.print('{"error": "Usage: /companion_mine <id> <x> <y> [count]"}')
      return
    end

    local companion = storage.companions[id]
    if not companion or not companion.entity or not companion.entity.valid then
      rcon.print('{"error": "Companion #' .. id .. ' not found"}')
      return
    end

    local entity = companion.entity
    local surface = entity.surface
    local position = {x = x, y = y}

    -- Check distance
    local distance = math.sqrt((position.x - entity.position.x)^2 + (position.y - entity.position.y)^2)
    if distance > 10 then  -- resource_reach_distance approximation
      rcon.print('{"error": "Too far from target position"}')
      return
    end

    -- Find minable entities at position
    local entities = surface.find_entities_filtered{
      position = position,
      radius = 2,
      type = {"resource", "tree", "simple-entity"}
    }

    if #entities == 0 then
      rcon.print('{"error": "No minable entities at position"}')
      return
    end

    local total_yield = 0
    local mined_items = {}

    for _, target in ipairs(entities) do
      if total_yield >= count then break end
      if target.valid and target.minable then
        local products = target.prototype.mineable_properties.products
        if products then
          for _, product in pairs(products) do
            local amount = product.amount or 1
            if total_yield + amount <= count then
              -- Mine and insert to companion inventory
              target.mine({ignore_minable=false, raise_destroyed=true})
              entity.insert({name=product.name, count=amount})
              total_yield = total_yield + amount
              mined_items[product.name] = (mined_items[product.name] or 0) + amount
            end
          end
        end
      end
    end

    local json_success, json_result = pcall(helpers.table_to_json, {
      id = id,
      mined = total_yield,
      items = mined_items
    })
    if json_success then
      rcon.print(json_result)
    else
      rcon.print('{"mined": ' .. total_yield .. '}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 2: Test via RCON**

```bash
bun -e "
import { RCONClient } from './src/rcon/client';
const client = new RCONClient({ host: '127.0.0.1', port: 34198, password: 'factorio' });
await client.connect();
console.log(await client.sendCommand('/companion_list'));
// Move companion near a resource first, then mine
console.log(await client.sendCommand('/companion_mine 1 0 0 10'));
await client.disconnect();
"
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add companion_mine RCON command"
```

---

### Task 7: Implement companion_craft RCON Command

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion_craft command**

Simplified crafting (fast mode, no recursion):

```lua
commands.add_command("companion_craft", "Craft item: /companion_craft <id> <item> [count]", function(command)
  local success, result = pcall(function()
    local args = command.parameter or ""
    local id_str, item, count_str = args:match("^(%d+)%s+(%S+)%s*(%d*)$")

    local id = tonumber(id_str)
    local count = tonumber(count_str) or 1

    if not id or not item then
      rcon.print('{"error": "Usage: /companion_craft <id> <item-name> [count]"}')
      return
    end

    local companion = storage.companions[id]
    if not companion or not companion.entity or not companion.entity.valid then
      rcon.print('{"error": "Companion #' .. id .. ' not found"}')
      return
    end

    local entity = companion.entity
    local force = entity.force

    -- Check recipe exists and is enabled
    local recipe = force.recipes[item]
    if not recipe then
      rcon.print('{"error": "Recipe for ' .. item .. ' not found"}')
      return
    end

    if not recipe.enabled then
      rcon.print('{"error": "Recipe for ' .. item .. ' is not unlocked"}')
      return
    end

    if recipe.category ~= "crafting" then
      rcon.print('{"error": "Item requires a machine to craft"}')
      return
    end

    -- Check ingredients
    local crafts_needed = math.ceil(count / (recipe.products[1].amount or 1))
    local missing = {}

    for _, ingredient in pairs(recipe.ingredients) do
      local have = entity.get_item_count(ingredient.name)
      local need = ingredient.amount * crafts_needed
      if have < need then
        missing[ingredient.name] = need - have
      end
    end

    if next(missing) then
      local json_success, json_result = pcall(helpers.table_to_json, {
        error = "Missing ingredients",
        missing = missing
      })
      if json_success then
        rcon.print(json_result)
      else
        rcon.print('{"error": "Missing ingredients"}')
      end
      return
    end

    -- Remove ingredients
    for _, ingredient in pairs(recipe.ingredients) do
      entity.remove_item({name = ingredient.name, count = ingredient.amount * crafts_needed})
    end

    -- Add crafted items
    local crafted = crafts_needed * (recipe.products[1].amount or 1)
    entity.insert({name = item, count = crafted})

    local json_success, json_result = pcall(helpers.table_to_json, {
      id = id,
      item = item,
      crafted = crafted
    })
    if json_success then
      rcon.print(json_result)
    else
      rcon.print('{"crafted": ' .. crafted .. '}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 2: Test via RCON**

```bash
bun -e "
import { RCONClient } from './src/rcon/client';
const client = new RCONClient({ host: '127.0.0.1', port: 34198, password: 'factorio' });
await client.connect();
// Give companion some materials first, then craft
console.log(await client.sendCommand('/companion_craft 1 iron-gear-wheel 2'));
await client.disconnect();
"
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add companion_craft RCON command"
```

---

### Task 8: Implement companion_inventory RCON Command

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion_inventory command**

```lua
commands.add_command("companion_inventory", "Get companion inventory: /companion_inventory <id>", function(command)
  local success, result = pcall(function()
    local id = tonumber(command.parameter)

    if not id then
      rcon.print('{"error": "Usage: /companion_inventory <id>"}')
      return
    end

    local companion = storage.companions[id]
    if not companion or not companion.entity or not companion.entity.valid then
      rcon.print('{"error": "Companion #' .. id .. ' not found"}')
      return
    end

    local entity = companion.entity
    local inventory = entity.get_main_inventory()

    if not inventory then
      rcon.print('{"error": "Cannot access inventory"}')
      return
    end

    local contents = inventory.get_contents()
    local items = {}

    -- Convert to array format for cleaner JSON
    for name, count in pairs(contents) do
      table.insert(items, {name = name, count = count})
    end

    local json_success, json_result = pcall(helpers.table_to_json, {
      id = id,
      items = items
    })
    if json_success then
      rcon.print(json_result)
    else
      rcon.print('{"error": "JSON serialization failed"}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 2: Test via RCON**

```bash
bun -e "
import { RCONClient } from './src/rcon/client';
const client = new RCONClient({ host: '127.0.0.1', port: 34198, password: 'factorio' });
await client.connect();
console.log(await client.sendCommand('/companion_inventory 1'));
await client.disconnect();
"
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add companion_inventory RCON command"
```

---

### Task 9: Implement companion_place RCON Command

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/control.lua`

**Step 1: Add companion_place command**

```lua
commands.add_command("companion_place", "Place entity: /companion_place <id> <entity> <x> <y> [direction]", function(command)
  local success, result = pcall(function()
    local args = command.parameter or ""
    local id_str, entity_name, x_str, y_str, dir_str = args:match("^(%d+)%s+(%S+)%s+([%d.-]+)%s+([%d.-]+)%s*(%d*)$")

    local id = tonumber(id_str)
    local x = tonumber(x_str)
    local y = tonumber(y_str)
    local direction = tonumber(dir_str) or 0  -- 0=north, 2=east, 4=south, 6=west

    if not id or not entity_name or not x or not y then
      rcon.print('{"error": "Usage: /companion_place <id> <entity> <x> <y> [direction 0-6]"}')
      return
    end

    local companion = storage.companions[id]
    if not companion or not companion.entity or not companion.entity.valid then
      rcon.print('{"error": "Companion #' .. id .. ' not found"}')
      return
    end

    local entity = companion.entity
    local surface = entity.surface
    local position = {x = x, y = y}

    -- Check distance
    local distance = math.sqrt((position.x - entity.position.x)^2 + (position.y - entity.position.y)^2)
    if distance > 10 then
      rcon.print('{"error": "Too far from target position"}')
      return
    end

    -- Check if companion has the item
    local item_count = entity.get_item_count(entity_name)
    if item_count < 1 then
      rcon.print('{"error": "Companion does not have ' .. entity_name .. '"}')
      return
    end

    -- Check if can place
    local can_place = surface.can_place_entity{
      name = entity_name,
      position = position,
      direction = direction,
      force = entity.force
    }

    if not can_place then
      rcon.print('{"error": "Cannot place entity at position"}')
      return
    end

    -- Place entity
    local placed = surface.create_entity{
      name = entity_name,
      position = position,
      direction = direction,
      force = entity.force,
      player = nil,  -- companion is not a player
      raise_built = true
    }

    if placed then
      entity.remove_item({name = entity_name, count = 1})
      local json_success, json_result = pcall(helpers.table_to_json, {
        id = id,
        placed = entity_name,
        position = {x = placed.position.x, y = placed.position.y},
        direction = placed.direction
      })
      if json_success then
        rcon.print(json_result)
      else
        rcon.print('{"success": true}')
      end
    else
      rcon.print('{"error": "Failed to place entity"}')
    end
  end)

  if not success then
    rcon.print('{"error": "' .. tostring(result) .. '"}')
  end
end)
```

**Step 2: Test via RCON**

```bash
bun -e "
import { RCONClient } from './src/rcon/client';
const client = new RCONClient({ host: '127.0.0.1', port: 34198, password: 'factorio' });
await client.connect();
// Companion needs the item in inventory first
console.log(await client.sendCommand('/companion_place 1 transport-belt 5 5'));
await client.disconnect();
"
```

**Step 3: Commit**

```bash
git add -A && git commit -m "feat: add companion_place RCON command"
```

---

### Task 10: Update mod version and documentation

**Files:**
- Modify: `%APPDATA%/Factorio/mods/ai-companion/info.json`
- Modify: `C:\Users\lveil\Desktop\Projects\factorio-ai-companion\claude.md`
- Modify: `C:\Users\lveil\Desktop\Projects\factorio-ai-companion\src\mcp\server.ts`

**Step 1: Update info.json version**

```json
{
  "name": "ai-companion",
  "version": "0.2.2",
  "title": "AI Companion",
  "author": "lveillard",
  "factorio_version": "2.0",
  "description": "Enables Claude Code to interact via chat and control companions. For Factorio 2.x",
  "dependencies": ["base >= 2.0"]
}
```

**Step 2: Update MCP server version**

In `src/mcp/server.ts` line 19, update version to "0.2.2".

**Step 3: Update claude.md with new commands**

Add to the "Lua Mod Commands" section:

```markdown
### Companion Commands (in-game)
- `/fac <message>` - Send message to Claude (default)
- `/fac spawn [n]` - Spawn n companions (default 1, max 10)
- `/fac list` - List active companions with positions
- `/fac kill [id]` - Kill companion by ID (or all if no ID)
- `/fac clear` - Clear message queue
- `/fac thread <id> <message>` - Send message to specific companion

### Companion RCON Commands (TypeScript calls these)
- `/companion_spawn [count] [x] [y]` - Spawn companions at position
- `/companion_list` - List all companions as JSON
- `/companion_kill [id]` - Kill companion(s)
- `/companion_move <id> <x> <y>` - Teleport companion to position
- `/companion_mine <id> <x> <y> [count]` - Mine resources
- `/companion_craft <id> <item> [count]` - Craft item
- `/companion_inventory <id>` - Get companion inventory
- `/companion_place <id> <entity> <x> <y> [direction]` - Place entity
```

**Step 4: Update version history in claude.md**

```markdown
- **0.2.2** - Companion characters with spawn/list/kill, action commands (move, mine, craft, place)
```

**Step 5: Commit**

```bash
git add -A && git commit -m "feat: update to v0.2.2 with companion system and action commands"
```

---

## Summary of New Commands

| Command | Type | Description |
|---------|------|-------------|
| `/fac spawn [n]` | In-game | Spawn 1-10 companions |
| `/fac list` | In-game | List companions |
| `/fac kill [id]` | In-game | Kill one/all companions |
| `/fac clear` | In-game | Clear message queue |
| `/fac thread <id> <msg>` | In-game | Message specific companion |
| `/companion_spawn` | RCON | Spawn companions |
| `/companion_list` | RCON | List as JSON |
| `/companion_kill` | RCON | Kill companions |
| `/companion_move` | RCON | Teleport (fast mode) |
| `/companion_mine` | RCON | Mine resources |
| `/companion_craft` | RCON | Craft items |
| `/companion_inventory` | RCON | Get inventory |
| `/companion_place` | RCON | Place entities |
