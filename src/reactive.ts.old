/**
 * Reactive Message Checker
 * Polls RCON until a message is found, then prints it and exits.
 * Designed to be used with TaskOutput blocking for reactive pattern.
 * Usage: bun run src/reactive.ts
 * Output: JSON per message on stdout
 */

import { RCONClient } from './rcon/client';
import { getRCONConfig } from './config';
import { connectWithRetry, sleep } from './utils/connection';

const POLL_INTERVAL = 1000;

const client = new RCONClient(getRCONConfig());

async function waitForMessage(): Promise<void> {
  try {
    await connectWithRetry(client, 30, 5000);
    console.error('Connected. Waiting for message...');

    while (true) {
      // Get only orchestrator messages (no target_companion)
      const response = await client.sendCommand('/fac_chat_get orchestrator');

      if (response.success && response.data) {
        const messages = JSON.parse(response.data || '[]');

        if (Array.isArray(messages) && messages.length > 0) {
          messages.forEach((msg: { player: string; message: string; tick: number }) => {
            console.log(JSON.stringify(msg));
          });

          await client.disconnect();
          process.exit(0);
        }
      }

      await sleep(POLL_INTERVAL);
    }
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

waitForMessage();
